---
layout:     post
title:      "JavaScript作用域和闭包的基本理解"
subtitle:   "收集、整理、汇总、理清思路"
date:       2017-09-18
author:     "BigBangBro"
header-img: "img/post-bg-js-version.jpg"
tags:
    - JavaScript 
---

# 理解JavaScript作用域和闭包

> 作用域和作用域链是javascript中非常重要的特性，对于他们的理解直接关系到对于整个javascript体系的理解，而闭包又是对作用域的延伸，也是在实际开发中经常使用的一个特性，实际上，不仅仅是javascript，在很多语言中都提供了闭包的特性。

### 1. 思考

* 对变量提升的理解

* this几种不同的使用场景
* 创建10个<a>标签，点击时弹出对应序号

* 对作用域和作用域链的理解

* 实际开发中闭包的应用

### 2.知识点
* 执行上下文
* 范围：一段<script>或者一个函数
* 全局：变量定义、函数声明
* 函数：变量定义、函数声明、this、arguments
```js
//函数声明
  function fn(){
   //.....
  }

  //函数表达式
  var fn1=function(){
  //.....
  }
```

```js
//全局
console.log(a);   //undefined
var a=100

fn('zhangsan')    //zhangsan 20
function fn(name){
  //函数
  console.log(this);    //Window
  console.log(arguments);    //"zhangsan"
  age=20
  console.log(name,age);
  var age
}

```
## this
#### *this要在执行时才确认值，定义时无法确认*
```js
var a={
name:'A',
fn:function(){
  console.log(this.name);
   }
}
a.fn()    //this===a
a.fn.call({name:'B'})   //this==={name:'B'}
var fn1=a.fn
fn1()   //this===Window

```
## 作用域
没有块级作用域
```js
if(true){
var name='zhangsan'
}
console.log(name);  //zhangsan
```
只有函数和全局作用域
```js
var a=100
function fn(){
var a=200
console.log('fn',a)
}
console.log('global',a) //global 100
fn()  //fn 200
```
### 作用域链
### 自由变量
```js
var a=100
function fn(){
var b=200

//当前作用域没定义的变量，即'自由变量'
console.log(a)

console.log(b)
}
fn()  //100 200
```
调用在当前作用域不存在的变量，便会向父级作用域查找。需要注意的是，父级作用域是函数定义时产生的，并非函数调用时。
```js
var a=100
function F1(){
var b=200
function F2(){
  var c=300
  console.log(a)  //a是自由变量，在F2中未找到便向父级作用域F1查找，仍未找到，继续向上查找，在Window中找到
  console.log(b)  //b是自由变量
  console.log(c)
}
F2()
}
F1()  //100 200 300
```
## 闭包
```js
//闭包的使用场景：函数作为返回值
function F1(){
var a=100
//返回一个函数
return function(){
  console.log(a)    //自由变量，父作用域查找
  }
}
//f1得到一个函数
var f1=F1()
var a=200
f1()    //100
```
```js
//闭包的使用场景：函数作为参数传递
function F1(){
  var a=100
  return function(){
    console.log(a)    //自由变量，父作用域查找
  }
}
var f1=F1()

function F2(fn){
  var a=200
  fn()
}
F2(f1)    //100
```

# 解决文章开头思考的问题
### 1. 对变量提升的理解
#### 在<script>或函数中，各个变量、函数的声明与定义会被提前
#### 执行上下文的知识参考这里：http://www.jianshu.com/p/a6d37c77e8db
### 2. this几种不同的使用场景
#### this的几种执行情况：
#### 作为构造函数执行
#### 作为对象属性执行
#### 作为普通函数执行
#### call apply bind
```js
//构造函数
  function Foo(name){
    this.name=name
  }
  var f=new Foo('zhangsan')
  //对象属性
  var obj={
    name:'zhangsan',
    printName:function(){
      console.log(this.name)
    }
  }
  obj.printName()
  //普通函数
  function fn(){
    console.log(this);
  }
  fn()

  //call apply bind
  function fn1(name,age){
    alert(name)
    console.log(this)
  }
  fn1.call({x:100},'zhangsan',20)

  var fn2=function (name,age){    //bind在函数声明的形式后不可用，必须是函数表达式
    alert(name)
    console.log(this)
  }.bind({y:200})
  fn2('zhangsan',20)
```
### 3.创建10个<a>标签，点击时弹出对应序号
##### 仔细体会
```js
var i
for(i=0;i<10;i++){
  (function(i){
    var a=document.createElement('a')
    a.innerHTML=i
    a.addEventListener('click',function(e){
      e.preventDefault()
      alert(i)
    })
    document.body.appendChild(a)
  })(i)
}
```
### 4.如何理解作用域
##### 自由变量
##### 作用域链，即自由变量的查找
##### 闭包的两个场景
### 5.实际开发中闭包的应用
```js
//闭包实际应用中主要用于封装变量，收敛权限
function isFirstLoad(){
  var _list=[]
  return function(id){
    if(_list.indexOf(id)>=0){
      return false
    }else {
      _list.push(id)
      return true
    }
  }
}

//使用
var firstLoad=isFirstLoad()
firstLoad(10) //true
firstLoad(10) //false
firstLoad(20) //true
//在isFirstLoad函数外，无法修改_list的值
```


